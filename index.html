<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Quoridor — Web App</title>
  <meta name="description" content="2-player Quoridor, playable in the browser. GitHub Pages-ready (single file)." />
  <style>
    :root{
      --bg:#0f1220;          /* app background */
      --panel:#171a2b;       /* side/top panels */
      --ink:#e7eaf6;         /* text */
      --muted:#9aa3c2;       /* secondary text */
      --accent:#7aa2ff;      /* focus / primary */
      --accent-2:#ffb454;    /* secondary accent */
      --bad:#ff6b6b;         /* invalid preview */
      --good:#33d17a;        /* valid preview */

      --cell:56px;           /* one playable cell size */
      --gap:12px;            /* wall lane thickness */
      --board-radius:18px;
      --shadow: 0 6px 24px rgba(0,0,0,.35);
    }

    html, body {
      height: 100%;
      background: radial-gradient(1200px 800px at 10% -10%, #1a1f39 0%, var(--bg) 70%);
      color: var(--ink);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Hiragino Kaku Gothic ProN", "Noto Sans JP", "Yu Gothic", sans-serif;
      margin:0;
    }

    .app{
      display:grid;
      grid-template-rows: auto 1fr;
      min-height:100dvh;
    }

    header{
      display:flex; align-items:center; gap:12px;
      padding:14px clamp(12px,3vw,24px);
      background: linear-gradient(180deg, #191d31 0%, #15192c 100%);
      border-bottom: 1px solid rgba(255,255,255,.06);
      position: sticky; top:0; z-index:10;
    }
    header h1{ font-size: 18px; margin:0; letter-spacing:.3px }
    .spacer{ flex: 1 }

    main{
      display:grid;
      grid-template-columns: minmax(300px, 1fr) auto minmax(260px, 380px);
      gap: clamp(12px, 3.5vw, 28px);
      padding: clamp(12px, 3.5vw, 28px);
      align-items: start;
    }

    /* BOARD GRID: 17x17 tracks = 9 cells + 8 wall lanes, both directions */
    #board{
      display:grid;
      grid-template-columns: repeat(8, var(--cell) var(--gap)) var(--cell);
      grid-template-rows: repeat(8, var(--cell) var(--gap)) var(--cell);
      background: linear-gradient(180deg, #101322, #12162a);
      border-radius: var(--board-radius);
      padding: 14px;
      box-shadow: var(--shadow);
      position: relative;
      user-select:none;
    }

    /* 9x9 playable squares */
    .cell{
      width: var(--cell); height: var(--cell);
      background: linear-gradient(180deg, #2a2f52, #212542);
      border-radius: 8px;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.04);
      position: relative;
      transition: transform .08s ease;
    }
    .cell:hover{ outline: 2px solid rgba(255,255,255,.06); outline-offset: -2px }

    /* Pawn pieces */
    .pawn{
      width: 56%; height: 56%;
      border-radius: 50%;
      position: absolute; inset:0; margin:auto;
      box-shadow: 0 6px 16px rgba(0,0,0,.35), inset 0 0 0 2px rgba(255,255,255,.15);
      transform: translateZ(0);
    }
    .p0{ background: radial-gradient(circle at 30% 25%, #9bc0ff, #5c86ff); }
    .p1{ background: radial-gradient(circle at 30% 25%, #ffd59a, #ff9b40); }

    /* Wall segments actually placed */
    .wall{ position:absolute; background: linear-gradient(180deg, #84521a, #5a3511); border-radius: 6px; box-shadow: 0 8px 22px rgba(0,0,0,.45), inset 0 0 0 1px rgba(255,255,255,.08) }
    .wall.v{ width: var(--gap); height: calc(var(--cell)*2 + var(--gap)); }
    .wall.h{ height: var(--gap); width: calc(var(--cell)*2 + var(--gap)); }

    /* Hover preview */
    .ghost{ position:absolute; pointer-events:none; opacity:.85; }
    .ghost.valid{ background: linear-gradient(180deg, rgba(51,209,122,.85), rgba(38,160,90,.85)); box-shadow: 0 0 0 2px rgba(255,255,255,.15) inset, 0 0 0 1px rgba(0,0,0,.4); }
    .ghost.invalid{ background: linear-gradient(180deg, rgba(255,107,107,.85), rgba(206,67,67,.85)); box-shadow: 0 0 0 2px rgba(255,255,255,.15) inset, 0 0 0 1px rgba(0,0,0,.4); }

    /* Move targets */
    .move-dot{
      position:absolute; width: 18px; height: 18px; border-radius: 50%;
      background: var(--good); box-shadow: 0 2px 10px rgba(51,209,122,.55);
      transform: translate(-50%, -50%); cursor: pointer;
      outline: 2px solid rgba(255,255,255,.12);
    }

    /* Right panel */
    .panel{
      background: var(--panel); padding: 16px; border-radius: 14px; box-shadow: var(--shadow);
      display:flex; flex-direction:column; gap:14px;
    }
    .row{ display:flex; align-items:center; gap:10px; flex-wrap:wrap }
    .muted{ color: var(--muted); font-size: 13px }

    .btn{
      appearance:none; border:1px solid rgba(255,255,255,.08); color:var(--ink);
      background: linear-gradient(180deg, #1c2140, #141939);
      padding:10px 14px; border-radius:12px; cursor:pointer;
      box-shadow: 0 2px 8px rgba(0,0,0,.25);
      font-weight:600; letter-spacing:.3px;
    }
    .btn:hover{ border-color: rgba(255,255,255,.18) }
    .btn.primary{ background: linear-gradient(180deg, #2b4b97, #1a2e62); border-color: rgba(122,162,255,.45) }
    .btn.warn{ background: linear-gradient(180deg, #6b1f2a, #3b0f15); border-color: rgba(255,107,107,.45) }

    .seg{
      display:inline-grid; grid-auto-flow:column; gap:6px; background:#0f1327; padding:6px; border-radius:12px; border:1px solid rgba(255,255,255,.06)
    }
    .seg button{ background:transparent; border:none; color:var(--muted); padding:8px 12px; border-radius:10px; cursor:pointer; font-weight:700 }
    .seg button.active{ background: #24305b; color:var(--ink); outline:1px solid rgba(255,255,255,.12) }

    .legend{ display:grid; grid-template-columns:auto 1fr; gap:6px 10px; align-items:center }
    .badge{ display:inline-flex; align-items:center; gap:8px; background:#0f1327; padding:8px 10px; border-radius:10px; border:1px solid rgba(255,255,255,.06) }
    .dot{ width:14px; height:14px; border-radius:50% }
    .dot.p0{ background: radial-gradient(circle at 30% 25%, #9bc0ff, #5c86ff)}
    .dot.p1{ background: radial-gradient(circle at 30% 25%, #ffd59a, #ff9b40)}

    footer{ color: var(--muted); text-align:center; padding: 8px 0 18px }

    @media (max-width: 980px){
      main{ grid-template-columns: 1fr; justify-items:center }
      #board{ order:1 }
      .panel{ order:2; width:min(700px, 100%) }
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1>Quoridor</h1>
      <div class="spacer"></div>
      <div class="seg" role="tablist" aria-label="Tool selector">
        <button id="tool-move" class="active" title="M キー">Move</button>
        <button id="tool-wall-h" title="H キー">Wall ⟂</button>
        <button id="tool-wall-v" title="V キー">Wall ∥</button>
      </div>
      <button id="btn-undo" class="btn" title="U キー">Undo</button>
      <button id="btn-new"  class="btn" title="N キー">New Game</button>
    </header>

    <main>
      <div class="panel" style="justify-self:center">
        <div class="row">
          <div class="badge"><span class="dot p0"></span> P1 Walls: <strong id="p0-walls" style="margin-left:6px">10</strong></div>
          <div class="badge"><span class="dot p1"></span> P2 Walls: <strong id="p1-walls" style="margin-left:6px">10</strong></div>
        </div>
        <div class="row">
          <div class="badge">Turn: <strong id="turn-label" style="margin-left:6px">P1</strong></div>
          <label class="badge" style="cursor:pointer"><input id="chk-hints" type="checkbox" style="margin-right:8px"/> Show move hints</label>
          <label class="badge" style="cursor:pointer"><input id="chk-paths" type="checkbox" style="margin-right:8px"/> Show shortest paths</label>
        </div>
        <div class="legend">
          <div class="muted">操作:</div>
          <div class="muted">駒を動かす場合は <strong>Move</strong> を選択し、緑の点をクリック。壁は <strong>Wall</strong> を選んで設置します（R で向き切替）。壁で両者の到達経路を完全に塞ぐことはできません。</div>
          <div class="muted">ショートカット:</div>
          <div class="muted">M/H/V = ツール, R = 壁の回転, U = Undo, N = New</div>
        </div>
      </div>

      <div id="board" aria-label="Quoridor board" role="application"></div>

      <div class="panel">
        <div style="font-weight:700">How to Deploy on GitHub Pages</div>
        <ol class="muted" style="margin:0 0 8px 18px; line-height:1.6">
          <li>Create a repo (e.g. <code>quoridor</code>) and add this single <code>index.html</code>.</li>
          <li>Commit &amp; push to <code>main</code> (or any branch).</li>
          <li>Open <em>Settings → Pages</em>, select the branch and <em>root</em> folder, then save.</li>
          <li>Your game will be live at <code>https://&lt;yourname&gt;.github.io/&lt;repo&gt;/</code>.</li>
        </ol>
        <div class="muted">（git.io は短縮 URL。必要なら GitHub Pages の URL を短縮して使えます）</div>
        <hr style="border:none; border-top:1px solid rgba(255,255,255,.08)">
        <div class="muted">Rules implemented: standard movement, jumps &amp; diagonal steps around a blocked opponent, wall placement with crossing/overlap checks, and path-existence validation (BFS). 2P local play.</div>
      </div>
    </main>

    <footer>
      © 2025 Quoridor (browser edition). No backend required.
    </footer>
  </div>

  <script>
  // --- Utilities -----------------------------------------------------------
  const BOARD_N = 9;                 // 9x9 cells
  const WALLS_PER_PLAYER = 10;       // standard rules

  const key = (x,y) => `${x},${y}`;
  const parseKey = s => s.split(',').map(Number);

  // DOM helpers
  const $ = sel => document.querySelector(sel);
  const el = (tag, props={}) => Object.assign(document.createElement(tag), props);

  // --- Game State ---------------------------------------------------------
  const state = {
    players:[
      { id:0, pos:{x:4,y:0}, goalY:8, walls:WALLS_PER_PLAYER },
      { id:1, pos:{x:4,y:8}, goalY:0, walls:WALLS_PER_PLAYER },
    ],
    turn: 0, // 0 or 1
    hWalls: new Set(), // horizontal wall top-left (x,y), 0..7
    vWalls: new Set(), // vertical wall top-left (x,y), 0..7
    history: [],       // for undo
    tool: 'move',      // 'move' | 'wall-h' | 'wall-v'
  };

  // --- Board Construction -------------------------------------------------
  const board = $('#board');

  // Build 9x9 playable cells onto the 17x17 track grid (cells sit at odd indices)
  function buildCells(){
    // Clear board children (walls and hints re-added by render)
    board.innerHTML = '';

    for(let y=0; y<BOARD_N; y++){
      for(let x=0; x<BOARD_N; x++){
        const c = el('div', { className:'cell' });
        c.dataset.x = String(x);
        c.dataset.y = String(y);
        // Place on grid (1-based line indices)
        c.style.gridColumn = (1 + x*2) + ' / span 1';
        c.style.gridRow    = (1 + y*2) + ' / span 1';
        c.addEventListener('click', () => onCellClick(x,y));
        board.appendChild(c);
      }
    }
  }

  // --- Walls Geometry & Queries ------------------------------------------
  function hasHorizontalWall(x,y){ return state.hWalls.has(key(x,y)); }
  function hasVerticalWall(x,y){ return state.vWalls.has(key(x,y)); }

  // Is movement blocked between (x,y) and (x+1,y) ? (right/left)
  function blockedLR(x,y){
    // movement across vertical boundary at column x/x+1; blocked if vertical wall at (x,y) or (x,y-1)
    return hasVerticalWall(x, y) || hasVerticalWall(x, y-1);
  }
  // Is movement blocked between (x,y) and (x,y+1)? (down/up)
  function blockedUD(x,y){
    // movement across horizontal boundary at row y/y+1; blocked if horizontal wall at (x,y) or (x-1,y)
    return hasHorizontalWall(x, y) || hasHorizontalWall(x-1, y);
  }

  // Validate placing a wall of orientation 'h'/'v' at (x,y) [0..7]
  function canPlaceWall(orient, x, y){
    if(x<0||y<0||x>7||y>7) return false;
    if(state.players[state.turn].walls <= 0) return false;
    if(orient==='h'){
      // Cannot overlap existing horizontal
      if(hasHorizontalWall(x,y)) return false;
      // Cannot cross an existing vertical at same slot
      if(hasVerticalWall(x,y)) return false;
    } else {
      if(hasVerticalWall(x,y)) return false;
      if(hasHorizontalWall(x,y)) return false;
    }
    // Simulate placement & ensure both players keep at least one path
    const undoToken = snapshot();
    if(orient==='h') state.hWalls.add(key(x,y)); else state.vWalls.add(key(x,y));
    const ok = playersHavePaths();
    // rollback
    restore(undoToken);
    return ok;
  }

  // --- Movement -----------------------------------------------------------
  function neighborsFrom(x,y){
    const n=[];
    // Left
    if(x>0 && !blockedLR(x-1,y)) n.push({x:x-1,y});
    // Right
    if(x<BOARD_N-1 && !blockedLR(x,y)) n.push({x:x+1,y});
    // Up
    if(y>0 && !blockedUD(x,y-1)) n.push({x,y:y-1});
    // Down
    if(y<BOARD_N-1 && !blockedUD(x,y)) n.push({x,y:y+1});
    return n;
  }

  // Legal moves including jumps and diagonal side-steps
  function legalMoves(pid){
    const me = state.players[pid];
    const other = state.players[1-pid];
    const moves = [];

    const adj = neighborsFrom(me.pos.x, me.pos.y);
    // If opponent is adjacent
    const oppAdj = adj.find(p => p.x===other.pos.x && p.y===other.pos.y);
    if(oppAdj){
      const dx = other.pos.x - me.pos.x;
      const dy = other.pos.y - me.pos.y;
      // Check straight jump beyond opponent
      const bx = other.pos.x + Math.sign(dx);
      const by = other.pos.y + Math.sign(dy);
      const inBoard = bx>=0 && bx<BOARD_N && by>=0 && by<BOARD_N;
      let straightBlocked = true;
      if(dx!==0){
        // Horizontal relationship; check block between opponent and beyond
        if(inBoard && !blockedLR(Math.min(other.pos.x, bx), other.pos.y)){
          straightBlocked = false;
          moves.push({x:bx, y:by});
        }
      } else if(dy!==0){
        if(inBoard && !blockedUD(other.pos.x, Math.min(other.pos.y, by))){
          straightBlocked = false;
          moves.push({x:bx, y:by});
        }
      }
      if(straightBlocked){
        // Diagonal side-steps around opponent, provided the path from opponent to that diagonal isn't walled
        if(dx!==0){ // opponent left/right
          const cand1 = {x: other.pos.x, y: other.pos.y-1};
          const cand2 = {x: other.pos.x, y: other.pos.y+1};
          if(cand1.y>=0 && !blockedUD(other.pos.x, cand1.y)) moves.push(cand1);
          if(cand2.y<BOARD_N && !blockedUD(other.pos.x, other.pos.y)) moves.push(cand2);
        } else { // opponent up/down
          const cand1 = {x: other.pos.x-1, y: other.pos.y};
          const cand2 = {x: other.pos.x+1, y: other.pos.y};
          if(cand1.x>=0 && !blockedLR(cand1.x, other.pos.y)) moves.push(cand1);
          if(cand2.x<BOARD_N && !blockedLR(other.pos.x, other.pos.y)) moves.push(cand2);
        }
      }
    }
    // Normal adjacent moves (excluding stepping onto opponent square)
    for(const p of adj){
      if(!(p.x===other.pos.x && p.y===other.pos.y)) moves.push(p);
    }

    // Deduplicate
    const seen = new Set();
    return moves.filter(m=>{ const k=key(m.x,m.y); if(seen.has(k)) return false; seen.add(k); return true; });
  }

  // --- Pathfinding to validate placements --------------------------------
  function playersHavePaths(){
    return [0,1].every(id => hasPathToGoal(id));
  }

  function hasPathToGoal(pid){
    const start = state.players[pid].pos;
    const goalY = state.players[pid].goalY;
    const Q=[start];
    const seen = new Set([key(start.x,start.y)]);
    while(Q.length){
      const p = Q.shift();
      if(p.y === goalY) return true;
      for(const n of neighborsFrom(p.x,p.y)){
        const k = key(n.x,n.y);
        if(!seen.has(k)){
          seen.add(k); Q.push(n);
        }
      }
    }
    return false;
  }

  // Compute one shortest path (for UI hints)
  function shortestPath(pid){
    const start = state.players[pid].pos;
    const goalY = state.players[pid].goalY;
    const Q=[start];
    const seen = new Set([key(start.x,start.y)]);
    const prev = new Map();
    while(Q.length){
      const p=Q.shift();
      if(p.y===goalY){
        // reconstruct
        const path=[p];
        let k=key(p.x,p.y);
        while(prev.has(k)){
          const v = prev.get(k);
          path.push(v); k = key(v.x,v.y);
        }
        return path.reverse();
      }
      for(const n of neighborsFrom(p.x,p.y)){
        const nk=key(n.x,n.y);
        if(!seen.has(nk)) { seen.add(nk); prev.set(nk,p); Q.push(n); }
      }
    }
    return [];
  }

  // --- Rendering ----------------------------------------------------------
  function clearDynamicOverlays(){
    // Remove all .wall, .pawn, .move-dot, .ghost overlays
    [...board.querySelectorAll('.wall, .pawn, .move-dot, .ghost')].forEach(n=>n.remove());
  }

  // Convert logical wall slot (orient, x,y) to board pixel-positioned DOM node
  function placeWallNode(orient, x, y, cls='wall'){
    const node = el('div', { className: cls + ' ' + (orient==='h'?'h':'v') });
    // Compute CSS absolute position relative to #board padding box
    const pad = 14; // board padding
    const cell = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--cell'));
    const gap  = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--gap'));

    if(orient==='h'){
      const colPx = pad + (x * (cell + gap));
      const rowPx = pad + (y * (cell + gap)) + cell; // gap row after cell
      node.style.left = colPx + 'px';
      node.style.top  = rowPx + 'px';
    } else {
      const colPx = pad + (x * (cell + gap)) + cell; // gap col after cell
      const rowPx = pad + (y * (cell + gap));
      node.style.left = colPx + 'px';
      node.style.top  = rowPx + 'px';
    }
    board.appendChild(node);
    return node;
  }

  function renderWalls(){
    // Horizontal
    for(const s of state.hWalls){ const [x,y] = parseKey(s); placeWallNode('h',x,y); }
    // Vertical
    for(const s of state.vWalls){ const [x,y] = parseKey(s); placeWallNode('v',x,y); }
  }

  function renderPawns(){
    for(const p of state.players){
      const {x,y} = p.pos;
      const c = board.querySelector(`.cell[data-x="${x}"][data-y="${y}"]`);
      const pawn = el('div', { className: 'pawn p'+p.id, title: 'P'+(p.id+1) });
      c.appendChild(pawn);
    }
  }

  function renderMoveHints(){
    if(!$('#chk-hints').checked || state.tool!=='move') return;
    const me = state.players[state.turn];
    for(const m of legalMoves(state.turn)){
      // position dot at cell center
      const cellEl = board.querySelector(`.cell[data-x="${m.x}"][data-y="${m.y}"]`);
      const dot = el('div', { className:'move-dot' });
      const rect = cellEl.getBoundingClientRect();
      const brect = board.getBoundingClientRect();
      dot.style.left = (rect.left - brect.left + rect.width/2) + 'px';
      dot.style.top  = (rect.top  - brect.top  + rect.height/2) + 'px';
      dot.addEventListener('click', ()=> movePawnTo(me.id, m.x, m.y));
      board.appendChild(dot);
    }
  }

  function renderPaths(){
    if(!$('#chk-paths').checked) return;
    const paths = [shortestPath(0), shortestPath(1)];
    for(let pid=0; pid<2; pid++){
      const path = paths[pid];
      for(const step of path){
        const c = board.querySelector(`.cell[data-x="${step.x}"][data-y="${step.y}"]`);
        if(!c) continue;
        c.style.outline = `2px dashed ${pid===0? 'rgba(122,162,255,.7)':'rgba(255,180,84,.8)'}`;
        c.style.outlineOffset = '-2px';
      }
    }
  }

  function resetCellOutlines(){
    for(const c of board.querySelectorAll('.cell')) c.style.outline='none';
  }

  function renderInfo(){
    $('#p0-walls').textContent = state.players[0].walls;
    $('#p1-walls').textContent = state.players[1].walls;
    $('#turn-label').textContent = state.turn===0? 'P1' : 'P2';
  }

  function renderAll(){
    clearDynamicOverlays();
    renderWalls();
    renderPawns();
    resetCellOutlines();
    renderMoveHints();
    renderPaths();
    renderInfo();
  }

  // --- Interaction --------------------------------------------------------
  function onCellClick(x,y){
    if(state.tool !== 'move') return;
    const me = state.players[state.turn];
    const moves = legalMoves(state.turn);
    if(moves.some(m=>m.x===x && m.y===y)){
      movePawnTo(me.id, x, y);
    }
  }

  function commit(action){
    // Push snapshot for undo
    state.history.push(snapshot());
    action();
    renderAll();
    checkWin();
  }

  function movePawnTo(pid, x, y){
    commit(()=>{
      state.players[pid].pos = {x,y};
      state.turn = 1 - state.turn;
    });
  }

  // Wall placement via tool buttons + hover ghost
  let ghost = null;
  function updateGhost(orient, x, y){
    if(ghost) ghost.remove();
    if(x==null || y==null) return;
    const ok = canPlaceWall(orient, x, y);
    ghost = placeWallNode(orient, x, y, 'ghost ' + (ok?'valid':'invalid'));
  }

  function placeWall(orient, x, y){
    if(!canPlaceWall(orient, x, y)) return;
    commit(()=>{
      (orient==='h' ? state.hWalls : state.vWalls).add(key(x,y));
      state.players[state.turn].walls--;
      state.turn = 1 - state.turn;
    });
  }

  // Map mouse position to nearest wall-slot (8x8 per orientation)
  function wallSlotFromPointer(evt, orient){
    const pad = 14; const cell = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--cell')); const gap = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--gap'));
    const r = board.getBoundingClientRect();
    const px = evt.clientX - r.left - pad;
    const py = evt.clientY - r.top  - pad;
    if(px<0||py<0) return {x:null,y:null};
    // Convert to slot coordinates by dividing repeated (cell+gap) tiles
    const tile = cell + gap;
    const tx = Math.floor(px / tile); // 0..8 (left cell index)
    const ty = Math.floor(py / tile);
    if(tx<0||tx>8||ty<0||ty>8) return {x:null,y:null};

    if(orient==='h'){
      // horizontal wall sits on gap-row between ty and ty+1, left anchored at tx (0..7)
      const withinGapRow = (py % tile) >= cell && (py % tile) < tile;
      if(!withinGapRow || tx>=8 || ty>=8) return {x:null,y:null};
      return {x:tx, y:ty};
    } else {
      const withinGapCol = (px % tile) >= cell && (px % tile) < tile;
      if(!withinGapCol || tx>=8 || ty>=8) return {x:null,y:null};
      return {x:tx, y:ty};
    }
  }

  board.addEventListener('mousemove', (e)=>{
    const tool = state.tool;
    if(tool==='move') { if(ghost) { ghost.remove(); ghost=null; } return; }
    const orient = tool==='wall-h' ? 'h' : 'v';
    const {x,y} = wallSlotFromPointer(e, orient);
    updateGhost(orient, x, y);
  });
  board.addEventListener('mouseleave', ()=>{ if(ghost){ ghost.remove(); ghost=null; } });
  board.addEventListener('click', (e)=>{
    const tool = state.tool;
    if(tool==='move') return; // handled by cells
    const orient = tool==='wall-h' ? 'h' : 'v';
    const {x,y} = wallSlotFromPointer(e, orient);
    if(x!=null) placeWall(orient, x, y);
  });

  // --- Win Check ----------------------------------------------------------
  function checkWin(){
    for(const p of state.players){
      if(p.pos.y === p.goalY){
        alert(`Player ${p.id+1} wins!`);
        // Freeze by disabling interactions until New Game
        state.tool = 'move';
        toggleToolButtons();
        board.style.pointerEvents='none';
        return true;
      }
    }
    return false;
  }

  // --- Undo / Snapshot ----------------------------------------------------
  function snapshot(){
    return JSON.stringify({
      players: state.players.map(p=>({ id:p.id, pos:{...p.pos}, goalY:p.goalY, walls:p.walls })),
      turn: state.turn,
      hWalls:[...state.hWalls], vWalls:[...state.vWalls]
    });
  }
  function restore(json){
    const s = JSON.parse(json);
    state.players.forEach((p,i)=>{ p.pos=s.players[i].pos; p.goalY=s.players[i].goalY; p.walls=s.players[i].walls; });
    state.turn = s.turn;
    state.hWalls = new Set(s.hWalls);
    state.vWalls = new Set(s.vWalls);
  }

  function undo(){
    const snap = state.history.pop();
    if(!snap) return;
    restore(snap);
    renderAll();
    board.style.pointerEvents='auto';
  }

  // --- UI Controls --------------------------------------------------------
  function toggleToolButtons(){
    $('#tool-move').classList.toggle('active', state.tool==='move');
    $('#tool-wall-h').classList.toggle('active', state.tool==='wall-h');
    $('#tool-wall-v').classList.toggle('active', state.tool==='wall-v');
  }

  $('#tool-move').addEventListener('click', ()=>{ state.tool='move'; toggleToolButtons(); renderAll(); });
  $('#tool-wall-h').addEventListener('click', ()=>{ state.tool='wall-h'; toggleToolButtons(); });
  $('#tool-wall-v').addEventListener('click', ()=>{ state.tool='wall-v'; toggleToolButtons(); });
  $('#btn-undo').addEventListener('click', undo);
  $('#btn-new').addEventListener('click', ()=>{ newGame(); });

  document.addEventListener('keydown', (e)=>{
    if(e.key==='m' || e.key==='M'){ state.tool='move'; toggleToolButtons(); renderAll(); }
    if(e.key==='h' || e.key==='H'){ state.tool='wall-h'; toggleToolButtons(); }
    if(e.key==='v' || e.key==='V'){ state.tool='wall-v'; toggleToolButtons(); }
    if(e.key==='r' || e.key==='R'){ state.tool = state.tool==='wall-h' ? 'wall-v' : state.tool==='wall-v' ? 'wall-h' : state.tool; toggleToolButtons(); }
    if(e.key==='u' || e.key==='U'){ undo(); }
    if(e.key==='n' || e.key==='N'){ newGame(); }
  });

  function newGame(){
    state.players[0].pos = {x:4,y:0}; state.players[0].walls = WALLS_PER_PLAYER;
    state.players[1].pos = {x:4,y:8}; state.players[1].walls = WALLS_PER_PLAYER;
    state.hWalls.clear(); state.vWalls.clear();
    state.history = [];
    state.turn = 0;
    state.tool='move'; toggleToolButtons();
    board.style.pointerEvents='auto';
    renderAll();
  }

  // --- Boot ---------------------------------------------------------------
  buildCells();
  newGame();
  </script>
</body>
</html>
